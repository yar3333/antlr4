/*
 * [The "BSD license"]
 *  Copyright (c) 2012-2016 Terence Parr
 *  Copyright (c) 2012-2016 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

phpTypeInitMap ::= [
	"int":"0",
	"float":"0.0",
	"bool":"false",
	default:"null" // anything other than a primitive type is an object
]

// args must be <object-model-object>, <fields-resulting-in-STs>

ParserFile(file, parser, namedActions, contextSuperClass) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
/** @noinspection UnnecessaryParenthesesInspection */
/** @noinspection PhpRedundantCatchClauseInspection */
/** @noinspection PhpUnusedAliasInspection */
/** @noinspection DegradedSwitchInspection */
/** @noinspection PhpUnusedLocalVariableInspection */
/** @noinspection SelfClassReferencingInspection */

namespace <file.genPackage>;
<endif>

<namedActions.header>
use Antlr4\\Atn\\ATN;
use Antlr4\\Atn\\ATNDeserializer;
use Antlr4\\Atn\\ParserATNSimulator;
use Antlr4\\Dfa\\DFA;
use Antlr4\\Error\\Exceptions\\FailedPredicateException;
use Antlr4\\Error\\Exceptions\\NoViableAltException;
use Antlr4\\Parser;
use Antlr4\\PredictionContexts\\PredictionContextCache;
use Antlr4\\Error\\Exceptions\\RecognitionException;
use Antlr4\\RuleContext;
use Antlr4\\Token;
use Antlr4\\TokenStream;
use Antlr4\\Vocabulary;
use Antlr4\\VocabularyImpl;

<parser>
>>

ListenerFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
namespace <file.genPackage>;
<endif>

<header>
use Antlr4\\Tree\\ParseTreeListener;

/**
 * This interface defines a complete listener for a parse tree produced by
 * {@link <file.parserName>}.
 */
interface <file.grammarName>Listener extends ParseTreeListener {
	<file.listenerNames:{lname |
/**
<if(file.listenerLabelRuleNames.(lname))>
 * Enter a parse tree produced by the {@code <lname>\}
 * labeled alternative in {@link <file.parserName>#<file.listenerLabelRuleNames.(lname)>\}.
<else>
 * Enter a parse tree produced by {@link <file.parserName>#<lname>\}.
<endif>
 * @param ctx the parse tree
 */
function enter<lname; format="cap">(<file.parserName>_<lname; format="cap">Context $ctx) : void;
/**
<if(file.listenerLabelRuleNames.(lname))>
 * Exit a parse tree produced by the {@code <lname>\}
 * labeled alternative in {@link <file.parserName>#<file.listenerLabelRuleNames.(lname)>\}.
<else>
 * Exit a parse tree produced by {@link <file.parserName>#<lname>\}.
<endif>
 * @param ctx the parse tree
 */
function exit<lname; format="cap">(<file.parserName>_<lname; format="cap">Context $ctx) : void;}; separator="\n">
}
>>

BaseListenerFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
namespace <file.genPackage>;
<endif>

<header>
use Antlr4\\ParserRuleContext;
use Antlr4\\Tree\\ErrorNode;
use Antlr4\\Tree\\TerminalNode;

/**
 * This class provides an empty implementation of {@link <file.grammarName>Listener},
 * which can be extended to create a listener which only needs to handle a subset
 * of the available methods.
 */
class <file.grammarName>BaseListener implements <file.grammarName>Listener
{
	<file.listenerNames:{lname |
/**
 * {@inheritDoc\}
 *
 * \<p>The default implementation does nothing.\</p>
 */
function enter<lname; format="cap">(<file.parserName>_<lname; format="cap">Context $ctx) : void { \}
/**
 * {@inheritDoc\}
 *
 * \<p>The default implementation does nothing.\</p>
 */
function exit<lname; format="cap">(<file.parserName>_<lname; format="cap">Context $ctx) : void { \}}; separator="\n">

	/**
	 * {@inheritDoc\}
	 *
	 * \<p>The default implementation does nothing.\</p>
	 */
	function enterEveryRule(ParserRuleContext $ctx) : void { }
	/**
	 * {@inheritDoc\}
	 *
	 * \<p>The default implementation does nothing.\</p>
	 */
	function exitEveryRule(ParserRuleContext $ctx) : void { }
	/**
	 * {@inheritDoc\}
	 *
	 * \<p>The default implementation does nothing.\</p>
	 */
	function visitTerminal(TerminalNode $node) : void { }
	/**
	 * {@inheritDoc\}
	 *
	 * \<p>The default implementation does nothing.\</p>
	 */
	function visitErrorNode(ErrorNode $node) : void { }
}
>>

VisitorFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
namespace <file.genPackage>;
<endif>

<header>
use Antlr4\\Tree\\ParseTreeVisitor;
<file.visitorNames:{lname | use <file.genPackage>\\Contexts\\<lname; format="cap">Context;}; separator="\n">

/**
 * This interface defines a complete generic visitor for a parse tree produced by {@link <file.parserName>}.
 */
interface <file.grammarName>Visitor extends ParseTreeVisitor
{
	<file.visitorNames:{lname |
/**
<if(file.visitorLabelRuleNames.(lname))>
 * Visit a parse tree produced by the {@code <lname>\}
 * labeled alternative in {@link <file.parserName>#<file.visitorLabelRuleNames.(lname)>\}.
<else>
 * Visit a parse tree produced by {@link <file.parserName>#<lname>\}.
<endif>
 * Must return the visitor result.
 * @param <lname; format="cap">Context $ctx the parse tree
 */
function visit<lname; format="cap">(<lname; format="cap">Context $ctx);}; separator="\n">
}
>>

BaseVisitorFile(file, header, namedActions) ::= <<
<fileHeader(file.grammarFileName, file.ANTLRVersion)>
<if(file.genPackage)>
namespace <file.genPackage>;
<endif>

<header>
use Antlr4\\Tree\\AbstractParseTreeVisitor;

/**
 * This class provides an empty implementation of {@link <file.grammarName>Visitor},
 * which can be extended to create a visitor which only needs to handle a subset
 * of the available methods.
 */
class <file.grammarName>BaseVisitor extends AbstractParseTreeVisitor implements <file.grammarName>Visitor
{
	<file.visitorNames:{lname |
/**
 * {@inheritDoc\}
 *
 * \<p>The default implementation returns the result of calling
 * {@link #visitChildren\} on {@code ctx\}.\</p>
 */
function visit<lname; format="cap">(Contexts\\<lname; format="cap">Context $ctx) { return $this->visitChildren($ctx); \}}; separator="\n">
}
>>

fileHeader(grammarFileName, ANTLRVersion) ::= <<
\<?php
// Generated from <grammarFileName; format="java-escape"> by ANTLR <ANTLRVersion>

>>

Parser(parser, atn, sempredFuncs, superClass, funcs_methods, funcs_classes) ::= <<
<Parser_(ctor="parser_ctor", ...)>
>>

Parser_(parser, atn, sempredFuncs, ctor, superClass, funcs_methods, funcs_classes) ::= <<
class <parser.name> extends <superClass; null="Parser">
{
	//static { RuntimeMetaData.checkVersion("<file.ANTLRVersion>", RuntimeMetaData.VERSION); }

	private static $__decisionToDFA;
	/**
	 * @return DFA[]
	 */
	protected static function _decisionToDFA() : array
	{
	    if (self::$__decisionToDFA === null)
	    {
	        self::$__decisionToDFA = [];
            for ($i = 0; $i \< self::_ATN()->getNumberOfDecisions(); $i++) {
                self::$__decisionToDFA[] = new DFA(self::_ATN()->getDecisionState($i), $i);
            }
	    }
	    return self::$__decisionToDFA;
	}

	private static $__sharedContextCache;
	protected static function _sharedContextCache() : PredictionContextCache { return self::$__sharedContextCache ?? (self::$__sharedContextCache = new PredictionContextCache()); }
	
	<if(parser.tokens)>
	const <parser.tokens:{k | <k>=<parser.tokens.(k)>}; separator=", ", wrap, anchor>;
	<endif>
	
	const <parser.rules:{r | RULE_<r.name> = <r.index>}; separator=", ", wrap, anchor>;
		
	/**
	 * @return string[]|\\ArrayObject
	 */
	private static function makeRuleNames() : \\ArrayObject
	{
		return new \\ArrayObject([ <parser.ruleNames:{r | "<r>"}; separator=", ", wrap, anchor> ]);
	}
	
	/**
	 * @var string[]|\\ArrayObject
	 */
	private static $_ruleNames;
	
	/**
	 * @return string[]|\\ArrayObject
	 */
	static function ruleNames() : \\ArrayObject { return self::$_ruleNames ?? (self::$_ruleNames = self::makeRuleNames()); }

	<vocabulary(parser.literalNames, parser.symbolicNames)>

	function getGrammarFileName() : string { return "<parser.grammarFileName; format="java-escape">"; }

	/**
	 * @return string[]|\\ArrayObject
	 */
	function getRuleNames() : \\ArrayObject { return self::ruleNames(); }

	function getSerializedATN() : string { return self::_serializedATN(); }

	function getATN() : ATN { return self::_ATN(); }

	<namedActions.members>
	<parser:(ctor)()>

<if(sempredFuncs)>
    function sempred(?RuleContext $_localctx, int $ruleIndex, int $predIndex) : bool
    {
        /** @noinspection DegradedSwitchInspection */
        switch ($ruleIndex) {
        <parser.sempredFuncs.values:{f|
    case <f.ruleIndex>:
        /** @noinspection PhpParamsInspection */
        return $this-><f.name>_sempred(/** @var Contexts\\<f.ctxType> */$_localctx, $predIndex);}; separator="\n">
        }
        return true;
    }
    <sempredFuncs.values; separator="\n">
<endif>

	<atn>

    <funcs_methods; separator="\n">
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace <file.genPackage>\\Contexts;

use Antlr4\\ParserRuleContext;
use Antlr4\\Tree\\ParseTreeVisitor;
use Antlr4\\Tree\\TerminalNode;
use <file.genPackage>\\<parser.name>;
use <file.genPackage>\\<file.grammarName>Visitor;

<funcs_classes; separator="\n">
>>

vocabulary(literalNames, symbolicNames) ::= <<

/**
 * @var string[]
 */
private const _LITERAL_NAMES = [ <literalNames:{t | <t>}; null="null", separator=", ", wrap, anchor> ];

/**
 * @var string[]
 */
private const _SYMBOLIC_NAMES = [ <symbolicNames:{t | <t>}; null="null", separator=", ", wrap, anchor> ];

private static $_VOCABULARY;
static function VOCABULARY() : Vocabulary { return self::$_VOCABULARY ?? (self::$_VOCABULARY = new VocabularyImpl(self::_LITERAL_NAMES, self::_SYMBOLIC_NAMES)); }

private static $_tokenNames;
/**
 * @return string[]
 * @deprecated Use {@link #VOCABULARY} instead.
 */
static function tokenNames() : array
{
	if (self::$_tokenNames === null)
	{
		self::$_tokenNames = [];
		$count = count(self::_SYMBOLIC_NAMES);
		for ($i = 0; $i \< $count; $i++) {
			self::$_tokenNames[] = self::VOCABULARY()->getLiteralName($i);
			if (self::$_tokenNames[$i] === null) {
				self::$_tokenNames[$i] = self::VOCABULARY()->getSymbolicName($i);
			}

			if (self::$_tokenNames[$i] === null) {
				self::$_tokenNames[$i] = "\<INVALID>";
			}
		}
	}
	return self::$_tokenNames;
}

/**
 * @return string[]
 * @deprecated
 */
function getTokenNames() : array { return self::tokenNames(); }

function getVocabulary() : Vocabulary { return self::VOCABULARY(); }
>>

dumpActions(recog, argFuncs, actionFuncs, sempredFuncs) ::= <<
<if(actionFuncs)>
function action(RuleContext $_localctx, int $ruleIndex, int $actionIndex) : void
{
	switch ($ruleIndex) {
	<recog.actionFuncs.values:{f|
case <f.ruleIndex>:
	<f.name>_action((<f.ctxType>)$_localctx, $actionIndex);
	break;}; separator="\n">
	}
}
<actionFuncs.values; separator="\n">
<endif>
<if(sempredFuncs)>
function sempred(RuleContext $_localctx, int $ruleIndex, int $predIndex) : bool
{
	switch ($ruleIndex) {
	<recog.sempredFuncs.values:{f|
case <f.ruleIndex>:
    /** @noinspection PhpParamsInspection */
	return <f.name>_sempred(/** @var Contexts\\<f.ctxType> */$_localctx, $predIndex);}; separator="\n">
	}
	return true;
}
<sempredFuncs.values; separator="\n">
<endif>
>>

parser_ctor(p) ::= <<
function __construct(TokenStream $input) {
	parent::__construct($input);
	$this->_interp = new ParserATNSimulator($this, self::_ATN(), self::_decisionToDFA(), self::_sharedContextCache());
}
>>

/* This generates a private method since the actionIndex is generated, making an
 * overriding implementation impossible to maintain.
 */
RuleActionFunction(r, actions) ::= <<
private function <r.name>_action(<r.ctxType> _localctx, int actionIndex) : void
{
	switch (actionIndex) {
	<actions:{index|
case <index>:
	<actions.(index)>
	break;}; separator="\n">
	}
}
>>

/* This generates a private method since the predIndex is generated, making an
 * overriding implementation impossible to maintain.
 */
RuleSempredFunction(r, actions) ::= <<
private function <r.name>_sempred(?Contexts\\<r.ctxType> $_localctx, int $predIndex) : bool
{
    /** @noinspection DegradedSwitchInspection */
	switch ($predIndex) {
	<actions:{index|
    case <index>:
	    return <actions.(index)>;}; separator="\n">
	}
	return true;
}
>>

RuleFunction(currentRule,args,code,locals,ruleCtx,altLabelCtxs,namedActions,finallyAction,exceptions,postamble) ::= <<
<if(currentRule.isGenerateClasses)>
<ruleCtx>
<altLabelCtxs:{l | <altLabelCtxs.(l)>}; separator="\n">
<endif>
<if(currentRule.isGenerateMethods)>
<if(currentRule.modifiers)><currentRule.modifiers:{f | <f> }><endif>function <currentRule.name>(<args; separator=",">) : Contexts\\<currentRule.ctxType>
{
    $_localctx = new Contexts\\<currentRule.ctxType>($this->_ctx, $this->getState()<currentRule.args:{a | , <a.name>}>);
    $this->enterRule($_localctx, <currentRule.startState>, <parser.name>::RULE_<currentRule.name>);
    <namedActions.init>
    <locals; separator="\n">
    try {
<if(currentRule.hasLookaheadBlock)>
        //int $_alt;
<endif>
        <code>
        <postamble; separator="\n">
        <namedActions.after>
    }
    <if(exceptions)>
    <exceptions; separator="\n">
    <else>
    catch (RecognitionException $re) {
        $_localctx->exception = $re;
        $this->_errHandler->reportError($this, $re);
        $this->_errHandler->recover($this, $re);
    }
    <endif>
    finally {
        <finallyAction>
        $this->exitRule();
    }
    return $_localctx;
}
<endif>
>>

LeftRecursiveRuleFunction(currentRule,args,code,locals,ruleCtx,altLabelCtxs,namedActions,finallyAction,postamble) ::= <<
<if(currentRule.isGenerateClasses)>
<ruleCtx>
<altLabelCtxs:{l | <altLabelCtxs.(l)>}; separator="\n">
<endif>

<if(currentRule.isGenerateMethods)>
<if(currentRule.modifiers)><currentRule.modifiers:{f | <f> }><endif>function <currentRule.name>(<args; separator=", ">) : Contexts\\<currentRule.ctxType>
{
	return $this->_<currentRule.name>(0<currentRule.args:{a | , <a.name>}>);
}

private function _<currentRule.name>(int $_p<args:{a | , <a>}>) : Contexts\\<currentRule.ctxType>
{
	$_parentctx = $this->_ctx; // ParserRuleContext
	$_parentState = $this->getState(); // int
	$_localctx = new Contexts\\<currentRule.ctxType>($this->_ctx, $_parentState<currentRule.args:{a | , <a.name>}>);
	/** @noinspection PhpUnusedLocalVariableInspection */
	$_prevctx = $_localctx;
	$_startState = <currentRule.startState>; // int
	$this->enterRecursionRule($_localctx, <currentRule.startState>, <parser.name>::RULE_<currentRule.name>, $_p);
	<namedActions.init>
	<locals; separator="\n">
	try {
<if(currentRule.hasLookaheadBlock)>
		// int $_alt;
<endif>
		<code>
		<postamble; separator="\n">
		<namedActions.after>
	}
	catch (RecognitionException $re) {
		$_localctx->exception = $re;
		$this->_errHandler->reportError($this, $re);
		$this->_errHandler->recover($this, $re);
	}
	finally {
		<finallyAction>
		$this->unrollRecursionContexts($_parentctx);
	}
	return $_localctx;
}
<endif>
>>

CodeBlockForOuterMostAlt(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= <<
<if(currentOuterMostAltCodeBlock.altLabel)>$_localctx = new Contexts\\<currentOuterMostAltCodeBlock.altLabel; format="cap">Context($_localctx);<endif>
$this->enterOuterAlt($_localctx, <currentOuterMostAltCodeBlock.alt.altNum>);
<CodeBlockForAlt(currentAltCodeBlock=currentOuterMostAltCodeBlock, ...)>
>>

CodeBlockForAlt(currentAltCodeBlock, locals, preamble, ops) ::= <<
{
<locals; separator="\n">
<preamble; separator="\n">
<ops; separator="\n">
}
>>

LL1AltBlock(choice, preamble, alts, error) ::= <<
$this->setState(<choice.stateNumber>);
$this->_errHandler->sync($this);
<if(choice.label)><labelref(choice.label)> = $this->_input->LT(1);<endif>
<preamble; separator="\n">
switch ($this->_input->LA(1)) {
<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
default:
	<error>
}
>>

LL1OptionalBlock(choice, alts, error) ::= <<
$this->setState(<choice.stateNumber>);
$this->_errHandler->sync($this);
switch ($this->_input->LA(1)) {
<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
default:
	break;
}
>>

LL1OptionalBlockSingleAlt(choice, expr, alts, preamble, error, followExpr) ::= <<
$this->setState(<choice.stateNumber>);
$this->_errHandler->sync($this);
<preamble; separator="\n">
if (<expr>) {
	<alts; separator="\n">
}
<!else if ( !(<followExpr>) ) <error>!>
>>

LL1StarBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
$this->setState(<choice.stateNumber>);
$this->_errHandler->sync($this);
<preamble; separator="\n">
while (<loopExpr>) {
	<alts; separator="\n">
	$this->setState(<choice.loopBackStateNumber>);
	$this->_errHandler->sync($this);
	<iteration>
}
>>

LL1PlusBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
$this->setState(<choice.blockStartStateNumber>); <! alt block decision !>
$this->_errHandler->sync($this);
<preamble; separator="\n">
do {
	<alts; separator="\n">
	$this->setState(<choice.stateNumber>); <! loopback/exit decision !>
	$this->_errHandler->sync($this);
	<iteration>
} while ( <loopExpr> );
>>

// LL(*) stuff

AltBlock(choice, preamble, alts, error) ::= <<
$this->setState(<choice.stateNumber>);
$this->_errHandler->sync($this);
<if(choice.label)><labelref(choice.label)> = $this->_input->LT(1);<endif>
<preamble; separator="\n">
switch ($this->getInterpreter()->adaptivePredict($this->_input, <choice.decision>, $this->_ctx) ) {
<alts:{alt |
case <i>:
	<alt>
	break;}; separator="\n">
}
>>

OptionalBlock(choice, alts, error) ::= <<
$this->setState(<choice.stateNumber>);
$this->_errHandler->sync($this);
switch ($this->getInterpreter()->adaptivePredict($this->_input, <choice.decision>, $this->_ctx) ) {
<alts:{alt |
case <i><if(!choice.ast.greedy)>+1<endif>:
	<alt>
	break;}; separator="\n">
}
>>

StarBlock(choice, alts, sync, iteration) ::= <<
$this->setState(<choice.stateNumber>);
$this->_errHandler->sync($this);
$_alt = $this->getInterpreter()->adaptivePredict($this->_input, <choice.decision>, $this->_ctx);
while ($_alt !== <choice.exitAlt> && $_alt !== ATN::INVALID_ALT_NUMBER ) {
	if ($_alt === 1<if(!choice.ast.greedy)>+1<endif> ) {
		<iteration>
		<alts> <! should only be one !>
	}
	$this->setState(<choice.loopBackStateNumber>);
	$this->_errHandler->sync($this);
	$_alt = $this->getInterpreter()->adaptivePredict($this->_input, <choice.decision>, $this->_ctx);
}
>>

PlusBlock(choice, alts, error) ::= <<
$this->setState(<choice.blockStartStateNumber>); <! alt block decision !>
$this->_errHandler->sync($this);
$_alt = 1<if(!choice.ast.greedy)>+1<endif>;
do {
	switch ($_alt) {
	<alts:{alt|
case <i><if(!choice.ast.greedy)>+1<endif>:
	<alt>
	break;}; separator="\n">
	default:
		<error>
	}
	$this->setState(<choice.loopBackStateNumber>); <! loopback/exit decision !>
	$this->_errHandler->sync($this);
	$_alt = $this->getInterpreter()->adaptivePredict($this->_input, <choice.decision>, $_ctx);
} while ($_alt !== <choice.exitAlt> && $_alt !== ATN::INVALID_ALT_NUMBER);
>>

Sync(s) ::= "sync(<s.expecting.name>);"

ThrowNoViableAlt(t) ::= "throw new NoViableAltException($this);"

TestSetInline(s) ::= <<
<s.bitsets:{bits | <if(rest(rest(bits.ttypes)))><bitsetBitfieldComparison(s, bits)><else><bitsetInlineComparison(s, bits)><endif>}; separator=" || ">
>>

// Java language spec 15.19 - shift operators mask operands rather than overflow to 0... need range test
testShiftInRange(shiftAmount) ::= <<
((<shiftAmount>) & ~0x3f) === 0
>>

// produces smaller bytecode only when bits.ttypes contains more than two items
bitsetBitfieldComparison(s, bits) ::= <%
(<testShiftInRange({<offsetShiftVar(s.varName, bits.shift)>})> && ((1 \<\< <offsetShiftVar(s.varName, bits.shift)>) & (<bits.ttypes:{ttype | (1 \<\< <offsetShiftConst(ttype, bits.shift)>)}; separator=" | ">)) !== 0)
%>

isZero ::= [
"0":true,
default:false
]

offsetShiftVar(shiftAmount, offset) ::= <%
<if(!isZero.(offset))>($<shiftAmount> - <offset>)<else>$<shiftAmount><endif>
%>
offsetShiftConst(shiftAmount, offset) ::= <%
<if(!isZero.(offset))>(self::<shiftAmount> - <offset>)<else>self::<shiftAmount><endif>
%>

// produces more efficient bytecode when bits.ttypes contains at most two items
bitsetInlineComparison(s, bits) ::= <%
<bits.ttypes:{ttype | $<s.varName> === self::<ttype>}; separator=" || ">
%>

cases(ttypes) ::= <<
<ttypes:{t | case <parser.name>::<t>:}; separator="\n">
>>

InvokeRule(r, argExprsChunks) ::= <<
$this->setState(<r.stateNumber>);
<if(r.labels)><r.labels:{l | <labelref(l)> = }><endif>$this-><if(r.ast.options.p)>_<endif><r.name>(<if(r.ast.options.p)><r.ast.options.p><if(argExprsChunks)>,<endif><endif><argExprsChunks>);
>>

MatchToken(m) ::= <<
$this->setState(<m.stateNumber>);
<if(m.labels)><m.labels:{l | <labelref(l)> = }><endif>$this->match(<parser.name>::<m.name>);
>>

MatchSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, false)>"

MatchNotSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, true)>"

CommonSetStuff(m, expr, capture, invert) ::= <<
$this->setState(<m.stateNumber>);
<if(m.labels)><m.labels:{l | <labelref(l)> = }>$this->_input->LT(1);<endif>
<capture>
if ( <if(invert)><m.varName> \<= 0 || <else>!<endif>(<expr>) ) {
	<if(m.labels)><m.labels:{l | <labelref(l)> = (Token)}><endif>$this->_errHandler->recoverInline($this);
}
else {
	if ($this->_input->LA(1) === Token::EOF ) $matchedEOF = true;
	$this->_errHandler->reportMatch($this);
	$this->consume();
}
>>

Wildcard(w) ::= <<
$this->setState(<w.stateNumber>);
<if(w.labels)><w.labels:{l | <labelref(l)> = }><endif>$this->matchWildcard();
>>

// ACTION STUFF

Action(a, foo, chunks) ::= "<chunks>"

ArgAction(a, chunks) ::= "<chunks>"

SemPred(p, chunks, failChunks) ::= <<
$this->setState(<p.stateNumber>);
/** @noinspection UnnecessaryParenthesesInspection */
if (!(<chunks>)) throw new FailedPredicateException($this, <p.predicate><if(failChunks)>, <failChunks><elseif(p.msg)>, <p.msg><endif>);
>>

ExceptionClause(e, catchArg, catchAction) ::= <<
catch (<catchArg>) {
	<catchAction>
}
>>

// lexer actions are not associated with model objects

LexerSkipCommand()  ::= "$this->skip();"
LexerMoreCommand()  ::= "$this->more();"
LexerPopModeCommand() ::= "$this->popMode();"

LexerTypeCommand(arg, grammar)      ::= "$this->_type = <arg>;"
LexerChannelCommand(arg, grammar)   ::= "$this->_channel = <arg>;"
LexerModeCommand(arg, grammar)      ::= "$this->_mode = <arg>;"
LexerPushModeCommand(arg, grammar)  ::= "$this->pushMode(<arg>);"

ActionText(t) ::= "<t.text>"
ActionTemplate(t) ::= "<t.st>"
ArgRef(a) ::= "$_localctx-><a.name>"
LocalRef(a) ::= "$_localctx-><a.name>"
RetValueRef(a) ::= "$_localctx-><a.name>"
QRetValueRef(a) ::= "$<ctx(a)>-><a.dict>-><a.name>"
/** How to translate $tokenLabel */
TokenRef(t) ::= "$<ctx(t)>-><t.name>"
LabelRef(t) ::= "$<ctx(t)>-><t.name>"
ListLabelRef(t) ::= "$<ctx(t)>-><ListLabelName(t.name)>"
SetAttr(s,rhsChunks) ::= "$<ctx(s)>-><s.name> = <rhsChunks>;"

TokenLabelType() ::= "<file.TokenLabelType; null={Token}>"
InputSymbolType() ::= "<file.InputSymbolType; null={Token}>"

TokenPropertyRef_text(t) ::= "($<ctx(t)>-><t.label>!=null?<ctx(t)>-><t.label>->getText():null)"
TokenPropertyRef_type(t) ::= "($<ctx(t)>-><t.label>!=null?<ctx(t)>-><t.label>->getType():0)"
TokenPropertyRef_line(t) ::= "($<ctx(t)>-><t.label>!=null?<ctx(t)>-><t.label>->getLine():0)"
TokenPropertyRef_pos(t) ::= "($<ctx(t)>-><t.label>!=null?<ctx(t)>-><t.label>->getCharPositionInLine():0)"
TokenPropertyRef_channel(t) ::= "($<ctx(t)>-><t.label>!=null?<ctx(t)>-><t.label>->getChannel():0)"
TokenPropertyRef_index(t) ::= "($<ctx(t)>-><t.label>!=null?<ctx(t)>-><t.label>->getTokenIndex():0)"
TokenPropertyRef_int(t) ::= "($<ctx(t)>-><t.label>!=null?Integer.valueOf(<ctx(t)>-><t.label>->getText()):0)"

RulePropertyRef_start(r) ::= "($<ctx(r)>-><r.label>!=null?(<ctx(r)>-><r.label>->start):null)"
RulePropertyRef_stop(r)	 ::= "($<ctx(r)>-><r.label>!=null?(<ctx(r)>-><r.label>->stop):null)"
RulePropertyRef_text(r)	 ::= "($<ctx(r)>-><r.label>!=null?\$this->_input->getText(<ctx(r)>-><r.label>->start,<ctx(r)>-><r.label>->stop):null)"
RulePropertyRef_ctx(r)	 ::= "$<ctx(r)>-><r.label>"
RulePropertyRef_parser(r)::= "\$this"

ThisRulePropertyRef_start(r) ::= "$_localctx->start"
ThisRulePropertyRef_stop(r)	 ::= "$_localctx->stop"
ThisRulePropertyRef_text(r)	 ::= "$this->_input->getText($_localctx->start, $this->_input->LT(-1))"
ThisRulePropertyRef_ctx(r)	 ::= "$_localctx"
ThisRulePropertyRef_parser(r)::= "$this"

NonLocalAttrRef(s)		      ::= "((<s.ruleName; format=\"cap\">Context)\$this->getInvokingContext(<s.ruleIndex>))-><s.name>"
SetNonLocalAttr(s, rhsChunks) ::= "((<s.ruleName; format=\"cap\">Context)\$this->getInvokingContext(<s.ruleIndex>))-><s.name> = <rhsChunks>;"

AddToLabelList(a) ::= "<ctx(a.label)>-><a.listName>->add(<labelref(a.label)>);"

TokenDecl(t) ::= "<TokenLabelType()> <t.name>"
TokenTypeDecl(t) ::= "int <t.name>;"
TokenListDecl(t) ::= "/** @var Token[] */$<t.name> = []"
RuleContextDecl(r) ::= "/** @var <r.ctxName> $<r.name> */"
RuleContextListDecl(rdecl) ::= "/** @var <rdecl.ctxName>[] */$<rdecl.name> = []"

ContextTokenGetterDecl(t) ::= "function <t.name>() : TerminalNode { return $this->getToken(<parser.name>::<t.name>, 0); }"

ContextTokenListGetterDecl(t)  ::= <<
    /**
     * @return <TerminalNode>[]
     */
    function <t.name>() : array
    {
        return $this->getTokens(<parser.name>::<t.name>);
    }
>>

ContextTokenListIndexedGetterDecl(t)  ::= <<
function <t.name>(int $i) : TerminalNode { return $this->getToken(<parser.name>::<t.name>, $i); }
>>

ContextRuleGetterDecl(r)       ::= <<
function <r.name>() : ?<r.ctxName>
{
    /** @noinspection PhpIncompatibleReturnTypeInspection */
	return $this->getTypedRuleContext(<r.ctxName>::class, 0);
}
>>

ContextRuleListGetterDecl(r)   ::= <<
/**
 * @return <r.ctxName>[]
 */
function <r.name>() : array
{
	return $this->getTypedRuleContexts(<r.ctxName>::class);
}
>>

ContextRuleListIndexedGetterDecl(r)   ::= <<
/**
 * @return <r.ctxName>[]
 */
function <r.name>() : array
{
	return $this->getTypedRuleContexts(<r.ctxName>::class);
}
function <r.name>At(int $i) : ?<r.ctxName>
{
    /** @noinspection PhpIncompatibleReturnTypeInspection */
    return $this->getTypedRuleContext(<r.ctxName>::class, $i);
}
>>

LexerRuleContext() ::= "RuleContext"

/** The rule context name is the rule followed by a suffix; e.g.,
 *	r becomes rContext.
 */
RuleContextNameSuffix() ::= "Context"

ImplicitTokenLabel(tokenName) ::= "<tokenName>"
ImplicitRuleLabel(ruleName)	  ::= "<ruleName>"
ImplicitSetLabel(id)		  ::= "_tset<id>"
ListLabelName(label)		  ::= "<label>"

CaptureNextToken(d) ::= "$<d.varName> = \$this->_input->LT(1);"
CaptureNextTokenType(d) ::= "$<d.varName> = $this->_input->LA(1);"

StructDecl(struct,ctorAttrs,attrs,getters,dispatchMethods,interfaces,extensionMembers) ::= <<
class <struct.name> extends <if(contextSuperClass)><contextSuperClass><else>ParserRuleContext<endif><if(interfaces)> implements <interfaces; separator=", "><endif>
{
	<attrs:{a | public <a>;}; separator="\n">
	<getters:{g | <g>}; separator="\n">
	<if(ctorAttrs)>function __construct(?ParserRuleContext $parent, int $invokingState) { parent::__construct($parent, $invokingState); }
	<endif>
	function __construct(?ParserRuleContext $parent, int $invokingState=null<ctorAttrs:{a | , <a>}>)
	{
		parent::__construct($parent, $invokingState);
		<struct.ctorAttrs:{a | $this-\><a.name> = $<a.name>;}; separator="\n">
	}
	
	function getRuleIndex() : int { return <parser.name>::RULE_<struct.derivedFromName>; }
<if(struct.provideCopyFrom)> <! don't need copy unless we have subclasses !>
	/**
	 * @param <struct.name> $ctx
	 */
	function copyFrom($ctx) : void
	{
		parent::copyFrom($ctx);
		<struct.attrs:{a | $this-\><a.name> = $ctx-><a.name>;}; separator="\n">
	}
<endif>
<if(dispatchMethods)>
    <dispatchMethods; separator="\n">
<endif>
<if(extensionMembers)>
    <extensionMembers; separator="\n">
<endif>
}
>>

AltLabelStructDecl(struct,attrs,getters,dispatchMethods) ::= <<
class <struct.name> extends <currentRule.name; format="cap">Context
{
	<attrs:{a | public <a>;}; separator="\n">
	<getters:{g | <g>}; separator="\n">
	function __construct(<currentRule.name; format="cap">Context $ctx) { parent::__construct($ctx); $this->copyFrom($ctx); }

	<dispatchMethods; separator="\n">
}
>>

ListenerDispatchMethod(method) ::= <<
function <if(method.isEnter)>enter<else>exit<endif>Rule(ParseTreeListener $listener) : void
{
	if ($listener instanceof <parser.grammarName>Listener ) $listener-><if(method.isEnter)>enter<else>exit<endif><struct.derivedFromName; format="cap">($this);
}
>>

VisitorDispatchMethod(method) ::= <<
function accept(ParseTreeVisitor $visitor)
{
	if ($visitor instanceof <parser.grammarName>Visitor) return $visitor->visit<struct.derivedFromName; format="cap">($this);
	return $visitor->visitChildren($this);
}
>>

AttributeDecl(d) ::= "<d.type> <d.name><if(d.initValue)> = <d.initValue><endif>"

/** If we don't know location of label def x, use this template */
labelref(x) ::= "<if(!x.isLocal)>((<x.ctx.name>)$_localctx).<endif><x.name>"

/** For any action chunk, what is correctly-typed context struct ptr? */
ctx(actionChunk) ::= "((<actionChunk.ctx.name>)$_localctx)"

// used for left-recursive rules
recRuleAltPredicate(ruleName,opPrec)  ::= "\$this->precpred(\$this->_ctx, <opPrec>)"
recRuleSetReturnAction(src,name)	  ::= "\$<name> = \$<src>-><name>;"
recRuleSetStopToken()                 ::= "$this->_ctx->stop = $this->_input->LT(-1);"

recRuleAltStartAction(ruleName, ctxName, label, isListLabel) ::= <<
$_localctx = new Contexts\\<ctxName>Context($_parentctx, $_parentState);
<if(label)>
<if(isListLabel)>
$_localctx-><label>->add($_prevctx);
<else>
$_localctx-><label> = $_prevctx;
<endif>
<endif>
<if(label)>$_localctx-><label> = $_prevctx;<endif>
$this->pushNewRecursionContext($_localctx, $_startState, <parser.name>::RULE_<ruleName>);
>>

recRuleLabeledAltStartAction(ruleName, currentAltLabel, label, isListLabel) ::= <<
$_localctx = new Contexts\\<currentAltLabel; format="cap">Context(new <ruleName; format="cap">Context($_parentctx, $_parentState));
<if(label)>
<if(isListLabel)>
((<currentAltLabel; format="cap">Context)$_localctx)-><label>->add($_prevctx);
<else>
((<currentAltLabel; format="cap">Context)$_localctx)-><label> = $_prevctx;
<endif>
<endif>
$this->pushNewRecursionContext($_localctx, $_startState, <parser.name>::RULE_<ruleName>);
>>

recRuleReplaceContext(ctxName) ::= <<
$_localctx = new Contexts\\<ctxName>Context($_localctx);
$_ctx = $_localctx;
$_prevctx = $_localctx;
>>

recRuleSetPrevCtx() ::= <<
if ($this->_parseListeners !== null) $this->triggerExitRuleEvent();
/** @noinspection PhpUnusedLocalVariableInspection */
$_prevctx = $_localctx;
>>


LexerFile(lexerFile, lexer, namedActions) ::= <<
<fileHeader(lexerFile.grammarFileName, lexerFile.ANTLRVersion)>
<if(lexerFile.genPackage)>
namespace <lexerFile.genPackage>;
<endif>

<namedActions.header>
use Antlr4\\Atn\\ATNDeserializer;
use Antlr4\\Atn\\LexerATNSimulator;
use Antlr4\\Lexer;
use Antlr4\\CharStream;
use Antlr4\\PredictionContexts\\PredictionContextCache;
use Antlr4\\Atn\\ATN;
use Antlr4\\Dfa\\DFA;
use Antlr4\\Vocabulary;
use Antlr4\\VocabularyImpl;

<lexer>
>>

Lexer(lexer, atn, actionFuncs, sempredFuncs, superClass) ::= <<
class <lexer.name> extends <superClass; null="Lexer">
{
	//static { RuntimeMetaData.checkVersion("<lexerFile.ANTLRVersion>", RuntimeMetaData.VERSION); }

	private static $__decisionToDFA;
	/**
	 * @return DFA[]
	 */
	protected static function _decisionToDFA() : array
	{
	    if (self::$__decisionToDFA === null)
	    {
	        self::$__decisionToDFA = [];
            for ($i = 0; $i \< self::_ATN()->getNumberOfDecisions(); $i++) {
                self::$__decisionToDFA[] = new DFA(self::_ATN()->getDecisionState($i), $i);
            }
	    }
	    return self::$__decisionToDFA;
	}

	/**
	 * @var PredictionContextCache
	 */
	private static $__sharedContextCache;
	protected static function _sharedContextCache() : PredictionContextCache { return self::$__sharedContextCache ?? (self::$__sharedContextCache = new PredictionContextCache()); }
	
	<if(lexer.tokens)>
	const <lexer.tokens:{k | <k>=<lexer.tokens.(k)>}; separator=", ", wrap, anchor>;
	<endif>
	
	<if(lexer.channels)>
	const
		<lexer.channels:{c | <c>=<lexer.channels.(c)>}; separator=", ", wrap, anchor>;
	<endif>
	
	<if(rest(lexer.modes))>
	const
		<rest(lexer.modes):{m | <m>=<i>}; separator=", ", wrap, anchor>;
	<endif>
	
	static $channelNames = [ "DEFAULT_TOKEN_CHANNEL", "HIDDEN"<if (lexer.channels)>, <lexer.channels:{c| "<c>"}; separator=", ", wrap, anchor><endif> ];

	static $modeNames = [ <lexer.modes:{m| "<m>"}; separator=", ", wrap, anchor> ];

	private static function makeRuleNames() : \\ArrayObject
	{
		return new \\ArrayObject([ <lexer.ruleNames:{r | "<r>"}; separator=", ", wrap, anchor> ]);
	}
	
	private static $_ruleNames;
	static function ruleNames() : \\ArrayObject { return self::$_ruleNames ?? (self::$_ruleNames = self::makeRuleNames()); }

	<vocabulary(lexer.literalNames, lexer.symbolicNames)>

	<namedActions.members>

	function __construct(CharStream $input)
	{
		parent::__construct($input);
		$this->_interp = new LexerATNSimulator($this, self::_ATN(), self::_decisionToDFA(), self::_sharedContextCache());
	}

	function getGrammarFileName() : string { return "<lexer.grammarFileName>"; }

	/**
	 * @return string[]|\\ArrayObject
	 */
	function getRuleNames() : \\ArrayObject { return self::ruleNames(); }

	function getSerializedATN() : string { return self::_serializedATN(); }

	/**
	 * @return string[] 
	 */
	function getChannelNames() : array { return self::$channelNames; }

	/**
	 * @return string[] 
	 */
	function getModeNames() : array { return self::$modeNames; }

	function getATN() : ATN { return self::_ATN(); }

	<dumpActions(lexer, "", actionFuncs, sempredFuncs)>
	<atn>
}
>>

SerializedATN(model) ::= <<
<if(rest(model.segments))>
<! requires segmented representation !>
private const _serializedATNSegments = <length(model.segments)>;
<model.segments:{segment|private const _serializedATNSegment<i0> =
	"<segment; wrap={"+<\n><\t>"}>";}; separator="\n">
private static $__serializedATN;
static function _serializedATN() : string
{
	if (self::$__serializedATN === null)
	{
		self::$__serializedATN = implode("", [
			<model.segments:{segment | _serializedATNSegment<i0>}; separator=",\n">
		]);
	}
	return self::$__serializedATN;
}
<else>
<! only one segment, can be inlined !>
static function _serializedATN() : string
{
	return
		"<model.serialized; wrap={".<\n><\t><\t>"}>";
}
<endif>
/**
 * @var ATN
 */
private static $__ATN;
static function _ATN() : ATN { return self::$__ATN ?? (self::$__ATN = (new ATNDeserializer())->deserialize(self::_serializedATN())); }
>>

/** Using a type to init value map, try to init a type; if not in table
 *	must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<phpTypeInitMap.(typeName)>
>>

codeFileExtension() ::= ".php"
