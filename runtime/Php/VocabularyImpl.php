<?php

namespace Antlr4;

/**
 * This class provides a default implementation of the {@link Vocabulary}
 * interface.
 *
 * @author Sam Harwell
 */
class VocabularyImpl implements Vocabulary
{
    const EMPTY_NAMES = [];

    /**
     * Gets an empty {@link Vocabulary} instance.
     *
     * <p>
     * No literal or symbol names are assigned to token types, so
     * {@link #getDisplayName(int)} returns the numeric value for all tokens
     * except {@link Token#EOF}.</p>
     */
    private static $_EMPTY_VOCABULARY;
    static function EMPTY_VOCABULARY() : self { return self::$_EMPTY_VOCABULARY ?? (self::$_EMPTY_VOCABULARY = new self([], [], [])); }

    /**
     * @var string[]
     */
    private $literalNames;

    /**
     * @var string[]
     */
    private $symbolicNames;

    /**
     * @var string[]
     */
    private $displayNames;

    /**
     * @var int
     */
    private $maxTokenType;


    /**
     * Constructs a new instance of {@link VocabularyImpl} from the specified
     * literal, symbolic, and display token names.
     *
     * @param string[] literalNames The literal names assigned to tokens, or {@code null}
     * if no literal names are assigned.
     * @param string[] symbolicNames The symbolic names assigned to tokens, or
     * {@code null} if no symbolic names are assigned.
     * @param string[] displayNames The display names assigned to tokens, or {@code null}
     * to use the values in {@code literalNames} and {@code symbolicNames} as
     * the source of display names, as described in
     * {@link #getDisplayName(int)}.
     *
     * @see #getLiteralName(int)
     * @see #getSymbolicName(int)
     * @see #getDisplayName(int)
     */
    public function __construct(?array $literalNames, ?array $symbolicNames, array $displayNames=null)
    {
        $this->literalNames = $literalNames ?? self::EMPTY_NAMES;
        $this->symbolicNames = $symbolicNames ?? self::EMPTY_NAMES;
        $this->displayNames = $displayNames ?? self::EMPTY_NAMES;

        // See note here on -1 part: https://github.com/antlr/antlr4/pull/1146
        $this->maxTokenType = max(count($this->displayNames), count($this->literalNames), count($this->symbolicNames)) - 1;
    }

	/**
     * Returns a {@link VocabularyImpl} instance from the specified set of token
     * names. This method acts as a compatibility layer for the single
     * {@code tokenNames} array generated by previous releases of ANTLR.
     *
     * <p>The resulting vocabulary instance returns {@code null} for
     * {@link #getLiteralName(int)} and {@link #getSymbolicName(int)}, and the
     * value from {@code tokenNames} for the display names.</p>
     *
     * @param string[] $tokenNames The token names, or {@code null} if no token names are available.
     * @return Vocabulary A {@link Vocabulary} instance which uses {@code tokenNames} for the display names of tokens.
     */
	static function fromTokenNames(?array $tokenNames) : Vocabulary
    {
        if (!$tokenNames) return self::EMPTY_VOCABULARY();

        $literalNames = $tokenNames; // copy array
        $symbolicNames = $tokenNames; // copy array
        foreach ($tokenNames as $i => $tokenName)
        {
            if ($tokenName === null) continue;

            if ($tokenName !== "") {
                $firstChar = $tokenName[0];
                if ($firstChar === '\'')
                {
                    $symbolicNames[$i] = null;
                    continue;
                }
                else if (ctype_upper($firstChar))
                {
                    $literalNames[$i] = null;
                    continue;
                }
            }

            // wasn't a literal or symbolic name
            $literalNames[$i] = null;
            $symbolicNames[$i] = null;
        }

        return new VocabularyImpl($literalNames, $symbolicNames, $tokenNames);
    }

	function getMaxTokenType() : int { return $this->maxTokenType; }

    function getLiteralName(int $tokenType) : ?string
    {
        if ($tokenType >= 0 && $tokenType < count($this->literalNames)) {
            return $this->literalNames[$tokenType];
        }
        return null;
    }

	function getSymbolicName(int $tokenType) : ?string
    {
        if ($tokenType >= 0 && $tokenType < count($this->symbolicNames)) {
            return $this->symbolicNames[$tokenType];
        }

        if ($tokenType === Token::EOF) return "EOF";

        return null;
    }

	function getDisplayName(int $tokenType) : string
    {
        if ($tokenType >= 0 && $tokenType < count($this->displayNames))
        {
            $displayName = $this->displayNames[$tokenType];
            if ($displayName !== null) return $displayName;
        }

        $literalName = $this->getLiteralName($tokenType);
        if ($literalName !== null) return $literalName;

        $symbolicName = $this->getSymbolicName($tokenType);
        if ($symbolicName !== null) return $symbolicName;

        return (string)$tokenType;
    }
}
